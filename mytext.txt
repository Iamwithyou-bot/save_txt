import numpy as np, trimesh, pyrender, imageio
from pathlib import Path

DATASET = "myObject"
root   = Path(__file__).resolve().parent
ply    = root / "gigaPose_datasets" / "datasets" / DATASET / "models" / "obj_000001.ply"
poses  = root / "gigaPose_datasets" / "datasets" / "templates" / DATASET / "object_poses" / "000001.npy"
out    = (root / "tmp" / "cnos_templates" / DATASET); out.mkdir(parents=True, exist_ok=True)

# --- Szene ---
mesh_tm = trimesh.load(ply, force='mesh')
scene   = pyrender.Scene(bg_color=[255,255,255,0], ambient_light=[0.6,0.6,0.6,1.0])
mesh_pr = pyrender.Mesh.from_trimesh(mesh_tm, smooth=False)
for prim in mesh_pr.primitives:
    prim.cull_face = None  # kein Backface-Culling
scene.add(mesh_pr)

w = h = 512
fx = fy = 900.0
cx, cy = w/2, h/2
cam      = pyrender.IntrinsicsCamera(fx, fy, cx, cy, znear=1e-4, zfar=1e4)
renderer = pyrender.OffscreenRenderer(w, h)
light    = pyrender.DirectionalLight(intensity=10.0)

T_co = np.load(poses)  # (N,4,4)  object->camera (wahrscheinlich OpenCV)
C    = np.diag([1, -1, -1, 1])   # OpenCV -> OpenGL Achsumklappung

variants = [
    ("inv",        lambda T: np.linalg.inv(T)),
    ("inv@C",      lambda T: np.linalg.inv(T) @ C),
    ("C@inv",      lambda T: C @ np.linalg.inv(T)),
    ("C@inv@C",    lambda T: C @ np.linalg.inv(T) @ C),
    # falls T_co eigentlich camera->object ist, probieren wir auch "raw":
    ("raw",        lambda T: T),
    ("raw@C",      lambda T: T @ C),
    ("C@raw",      lambda T: C @ T),
    ("C@raw@C",    lambda T: C @ T @ C),
]

def visible_ratio(Tpose):
    cn = scene.add(cam, pose=Tpose); ln = scene.add(light, pose=Tpose)
    color, depth = renderer.render(scene)
    scene.remove_node(cn); scene.remove_node(ln)
    vr = float(np.isfinite(depth).mean())
    return vr, color

# 1) beste Variante anhand des ersten Poses schätzen
scores = []
for name, fn in variants:
    vr, probe = visible_ratio(fn(T_co[0]))
    imageio.v2.imwrite(out / f"_probe_{name}.png", probe)
    scores.append((vr, name))
scores.sort(reverse=True)
best_vr, best_name = scores[0]
print("Beste Variante:", best_name, "sichtbar:", f"{best_vr:.3f}")

if best_vr < 0.01:
    print("⚠️ Keine Variante sieht das Objekt. Versuche fx/fy kleiner (z.B. 600) oder prüfe die Einheiten.")
    raise SystemExit(1)

# 2) alle Templates mit der besten Variante rendern
fn = dict(variants)[best_name]
count = 0
for i, T in enumerate(T_co):
    Tpose = fn(T)
    cn = scene.add(cam, pose=Tpose); ln = scene.add(light, pose=Tpose)
    color, depth = renderer.render(scene)
    imageio.v2.imwrite(out / f"tpl_{i:03d}.png", color)
    scene.remove_node(cn); scene.remove_node(ln)
    count += 1

print(f"Saved {count} templates to {out}")
