import numpy as np, trimesh, pyrender, imageio
from pathlib import Path

DATASET = "myObject"
root   = Path(__file__).resolve().parent
ply    = root / "gigaPose_datasets" / "datasets" / DATASET / "models" / "obj_000001.ply"
poses  = root / "gigaPose_datasets" / "datasets" / "templates" / DATASET / "object_poses" / "000001.npy"
out    = (root / "tmp" / "cnos_templates" / DATASET); out.mkdir(parents=True, exist_ok=True)

# --- Szene mit Kontrast ---
mesh_tm = trimesh.load(ply, force='mesh')
# sicheres Material (sichtbar), glatte Normals
mat = pyrender.MetallicRoughnessMaterial(
    baseColorFactor=(0.85, 0.2, 0.2, 1.0), roughnessFactor=0.9, metallicFactor=0.0
)
mesh_pr = pyrender.Mesh.from_trimesh(mesh_tm, smooth=True, material=mat)
for prim in mesh_pr.primitives: prim.cull_face = None  # doppelseitig

scene = pyrender.Scene(bg_color=[15,15,15,255], ambient_light=[0.35,0.35,0.35,1.0])
scene.add(mesh_pr)

w = h = 512
# weiterer Blickwinkel für mehr „Sicherheit“
fx = fy = 600.0
cx, cy = w/2, h/2
cam      = pyrender.IntrinsicsCamera(fx, fy, cx, cy, znear=1e-4, zfar=1e4)
renderer = pyrender.OffscreenRenderer(w, h)

# 3 Lichter (aus Kamerarichtung + von oben/seitlich)
key   = pyrender.DirectionalLight(intensity=6.0)
fill  = pyrender.DirectionalLight(intensity=4.0)
rim   = pyrender.DirectionalLight(intensity=4.0)

T_co = np.load(poses)             # (N,4,4) object->camera  (OpenCV)
C    = np.diag([1,-1,-1,1])       # OpenCV -> OpenGL Achsumklappung

variants = [
    ("inv",        lambda T: np.linalg.inv(T)),
    ("inv@C",      lambda T: np.linalg.inv(T) @ C),
    ("C@inv",      lambda T: C @ np.linalg.inv(T)),
    ("C@inv@C",    lambda T: C @ np.linalg.inv(T) @ C),
    ("raw",        lambda T: T),
    ("raw@C",      lambda T: T @ C),
    ("C@raw",      lambda T: C @ T),
    ("C@raw@C",    lambda T: C @ T @ C),
]

def render_once(Tpose, save_probe=None):
    """Render, mehrere Lichter platzieren, RGB (ohne Alpha) zurückgeben."""
    cn = scene.add(cam, pose=Tpose)
    ln1 = scene.add(key,  pose=Tpose)
    # leichte Verschiebungen für fill/rim
    T_up    = Tpose.copy();  T_up[:3,3]  += np.array([0, 0.2, 0])
    T_side  = Tpose.copy();  T_side[:3,3]+= np.array([0.2, 0, 0])
    ln2 = scene.add(fill, pose=T_up)
    ln3 = scene.add(rim,  pose=T_side)
    color, depth = renderer.render(scene)
    scene.remove_node(cn); scene.remove_node(ln1); scene.remove_node(ln2); scene.remove_node(ln3)
    rgb = color[:, :, :3]  # Alpha verwerfen -> keine weiße Transparenz
    if save_probe is not None:
        imageio.v2.imwrite(save_probe, rgb)
    vr = float(np.isfinite(depth).mean())  # „wie viel“ im Bild ist belegt
    return vr, rgb

# 1) Beste Pose-Konvention automatisch wählen (auf erstem Pose-Eintrag)
scores = []
for name, fn in variants:
    vr, rgb = render_once(fn(T_co[0]), save_probe=out / f"_probe_{name}.png")
    scores.append((vr, name))
scores.sort(reverse=True)
best_vr, best_name = scores[0]
print("Beste Variante:", best_name, "sichtbar:", f"{best_vr:.3f}")
if best_vr < 0.02:
    print("⚠️ Nichts sichtbar – ggf. fx/fy noch kleiner (z.B. 450) oder Einheiten prüfen.")
    raise SystemExit(1)

# 2) Alle Templates mit bester Variante rendern
fn = dict(variants)[best_name]
count = 0
for i, T in enumerate(T_co):
    _, rgb = render_once(fn(T))
    imageio.v2.imwrite(out / f"tpl_{i:03d}.png", rgb)
    count += 1
print(f"Saved {count} templates to {out}")
